#pragma once

#include "em/macros/meta/common.h"
#include "em/macros/meta/if_else.h"
#include "em/macros/portable/warnings.h"
#include "em/refl/macros/structs/core.h"
#include "utils/type_name.h"

#include <fmt/format.h>

#include <functional>
#include <map>
#include <stdexcept>
#include <string>

namespace em::Refl::Derived
{
    // Include `em/refl/access/structs/derived.h` for the user-facing functions.

    // Whether `I` is a `Base::Interface` created by `EM_REGISTER_DERIVED(Interface, ...)` in the class `Bsae`.
    template <typename I>
    concept Interface = requires{typename I::_em_IsRegDerivedInterface;};

    // `I` is `Base::Interface`, where `Interface` is the identifier that was passed to `EM_REGISTER_DERIVED()` as the interface name.
    // Stores a list of implementations of this interface, for the classes derived from `Base`.
    // The keys are the derived class names from `em::TypeName()`.
    template <Interface I>
    using DerivedMap = std::map<std::string, const I *, std::less<>>;

    namespace detail
    {
        template <Interface I>
        [[nodiscard]] DerivedMap<I> &GetDerivedMap()
        {
            static DerivedMap<I> ret;
            return ret;
        }

        template <Interface I, typename D, typename DI>
        void RegisterDerived()
        {
            static const DI impl{};
            if (!GetDerivedMap<I>().try_emplace(std::string(em::TypeName<D>()), &impl).second)
                throw std::runtime_error(fmt::format("Internal error: Duplicate derived class registered: {}", em::TypeName<D>()));
        }
    }
}

// This is a control statement that can be added at the beginning of `EM_REFL(...)` to make
//   every class derived from this (including indirectly) register itself.
// Combine this with `EM_STATIC_VIRTUAL()` (see below) to type-erase various operations on the derived classes.
// Does nothing if there's zero `EM_STATIC_VIRTUAL()`.
// `interface_name_` is a unique name per class.
// `...` is a condition to check for the derived classes, in terms of `_em_Self` and `_em_Derived`. You should check at least `derived_from` or `is_base_of`,
//   or you'll incorrectly get some non-derived classes too. Consult `EM_REFL_INHERITANCE_HOOK()` for more details.
#define EM_REGISTER_DERIVED(interface_name_, .../*cond*/) \
        EM_REFL_PREPROCESS_LOW(SF_NULL, DETAIL_EM_REGISTER_DERIVED_STEP, DETAIL_EM_REGISTER_DERIVED_FINAL, (interface_name_, (__VA_ARGS__), /*annotations are collected here*/))

// Usage: `EM_STATIC_VIRTUAL(FuncName, (params...) -> ReturnType)(return whatever<_em_T>();)`.
// In the function body (last argument), `_em_T` is the type of the derived class.
// Implementation detail: Here we aren't using `EM_REFL_ANNOTATE_LOW()` to support this call syntax, but the end result is equivalent.
#define EM_STATIC_VIRTUAL(name_, ...) (annotation, em_static_virtual, "`EM_STATIC_VIRTUAL()` requires `EM_REGISTER_DERIVED()`", name_, (__VA_ARGS__), DETAIL_EM_STATIC_VIRTUAL_BODY
#define DETAIL_EM_STATIC_VIRTUAL_BODY(...) __VA_ARGS__)(_em_meta)


#define DETAIL_EM_REGISTER_DERIVED_STEP(n, d, kind_, ...) EM_CAT(DETAIL_EM_REGISTER_DERIVED_STEP_KIND_, kind_)(d, __VA_ARGS__)
#define DETAIL_EM_REGISTER_DERIVED_STEP_KIND_field(d, ...) d, (field,__VA_ARGS__) // Keep.
#define DETAIL_EM_REGISTER_DERIVED_STEP_KIND_verbatim(d, ...) d, (verbatim,__VA_ARGS__) // Keep.
#define DETAIL_EM_REGISTER_DERIVED_STEP_KIND_annotation(d, category_, ...) EM_IF_CAT_ADDS_COMMA(DETAIL_EM_REGISTER_DERIVED_CHECK_, category_)(DETAIL_EM_REGISTER_DERIVED_STEP_annotation_1(EM_IDENTITY d, __VA_ARGS__))(d, (annotation, category_, __VA_ARGS__))
#define DETAIL_EM_REGISTER_DERIVED_STEP_annotation_1(...) DETAIL_EM_REGISTER_DERIVED_STEP_annotation_2(__VA_ARGS__)
#define DETAIL_EM_REGISTER_DERIVED_STEP_annotation_2(interface_name_, cond_, seq_, error_if_unused_, ...) (interface_name_, cond_, seq_(__VA_ARGS__)), (annotation, em_static_virtual, /*no unused flag*/, __VA_ARGS__) // Store this annotation to data, but also emit it back without the unused flag.
#define DETAIL_EM_REGISTER_DERIVED_CHECK_em_static_virtual ,

#define DETAIL_EM_REGISTER_DERIVED_FINAL(n, d) DETAIL_EM_REGISTER_DERIVED_FINAL_1(n, EM_IDENTITY d)
// We could error here if `seq` is empty, but instead we no-op, just in case. We don't lose anything by doing this, as we don't generate any code.
// This can be helpful if the list of `EM_STATIC_VIRTUAL` is generated by a macro, or something.
#define DETAIL_EM_REGISTER_DERIVED_FINAL_1(...) DETAIL_EM_REGISTER_DERIVED_FINAL_2(__VA_ARGS__)
#define DETAIL_EM_REGISTER_DERIVED_FINAL_2(n, interface_name_, cond_, .../*seq*/) __VA_OPT__(DETAIL_EM_REGISTER_DERIVED_FINAL_3(n, interface_name_, cond_, __VA_ARGS__))
#define DETAIL_EM_REGISTER_DERIVED_FINAL_3(n, interface_name_, cond_, seq_) \
    (verbatim, body, register_derived,, \
        struct interface_name_ \
        { \
            using _em_IsRegDerivedInterface = void; /* Mark the class so we know it's a valid interface. */\
            virtual ~interface_name_() = default; \
            SF_CAT(SF_FOR_EACH, n)(DETAIL_EM_REGISTER_DERIVED_BODY_INTERFACE, SF_NULL, SF_NULL,, seq_) \
        }; \
        template <typename _em_Derived> \
        struct EM_CAT(_em_RegisterDerivedImpl, interface_name_) : interface_name_ \
        { \
            SF_CAT(SF_FOR_EACH, n)(DETAIL_EM_REGISTER_DERIVED_BODY_IMPL, SF_NULL, SF_NULL,, seq_) \
        }; \
        EM_REFL_INHERITANCE_HOOK(EM_CAT(em_register_derived_, interface_name_), cond_, ::em::Refl::Derived::detail::RegisterDerived<interface_name_, _em_Derived, EM_CAT(_em_RegisterDerivedImpl, interface_name_)<_em_Derived>>();)\
    )

#define DETAIL_EM_REGISTER_DERIVED_BODY_INTERFACE(n, d, name_, p_params_ret_, .../*body*/) \
    /* Using a trailing return type to avoid having to wrap it in `std::type_identity_t`. */\
    EM_SILENCE_UNUSED_ATTRIBUTE( [[nodiscard]] ) virtual auto name_ DETAIL_EM_REGISTER_DERIVED_INJECT_CONST EM_IDENTITY p_params_ret_ = 0;

#define DETAIL_EM_REGISTER_DERIVED_BODY_IMPL(n, d, name_, p_params_ret_, .../*body*/) \
    /* Using a trailing return type to avoid having to wrap it in `std::type_identity_t`. */\
    EM_SILENCE_UNUSED_ATTRIBUTE( [[nodiscard]] ) auto name_ DETAIL_EM_REGISTER_DERIVED_INJECT_CONST EM_IDENTITY p_params_ret_ override {__VA_ARGS__}

#define DETAIL_EM_REGISTER_DERIVED_INJECT_CONST(...) (__VA_ARGS__) const

#define DETAIL_EM_REGISTER_DERIVED_PARAM_DECLS(n, params_) SF_CAT(SF_FOR_EACH, n)(SF_NULL, DETAIL_EM_REGISTER_DERIVED_BODY_PARAM_DECL, SF_NULL, EM_EMPTY, params_)
#define DETAIL_EM_REGISTER_DERIVED_STEP_PARAM_DECL(n, d, name_, .../*type*/) EM_COMMA, d(,) std::type_identity_t<__VA_ARGS__> name_
