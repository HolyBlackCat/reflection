#pragma once

#include "em/macros/utils/forward.h"
#include "em/meta/common.h"
#include "em/meta/lists.h"
#include "em/refl/common.h"

#include <cstddef>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>

namespace em::Refl::Structs
{
    namespace detail
    {
        // Here we try to get traits from `_adl_em_refl_Struct()` if that's available (that's generated by `EM_REFL(...)` or written manually by the user),
        //   and fall back to `_adl_em_refl_StructFallback()` otherwise (that's primarily for internal use, but you user can provide it too).
        // The fallback is used e.g. to provide traits for tuple-like types.

        template <typename T>
        struct SelectTraits
        {
            template <typename U = T>
            using type = decltype(_adl_em_refl_StructFallback(custom::AdlDummy{}, std::declval<const U *>()));
        };

        template <typename T>
        requires requires{_adl_em_refl_Struct(custom::AdlDummy{}, std::declval<const T *>());}
        struct SelectTraits<T>
        {
            template <typename = T>
            using type = decltype(_adl_em_refl_Struct(custom::AdlDummy{}, std::declval<const T *>()));
        };
    }

    // Access the internal traits class.
    // Normally this is for internal use. But the extra modules for `EM_REFL(...)` can add stuff to those traits, and then they'll read it from here.
    template <typename T>
    using Traits = typename detail::SelectTraits<std::remove_cvref_t<T>>::template type<std::remove_cvref_t<T>>;


    // A struct type. Must either contain `EM_REFL` macro or implement the same customization points.
    template <typename T>
    concept Type = requires{typename Traits<T>;};

    template <typename T>
    concept TypeUnqualified = Meta::cvref_unqualified<T> && Type<T>;

    // The number of data members in a struct.
    template <Type T>
    constexpr int num_members = Traits<T>::num_members;

    template <typename T, int I>
    concept ValidMemberIndex = Type<T> && I >= 0 && I < num_members<T>;


    // Get `I`th member of a struct, as if the struct was const.
    template <int I, Meta::Deduce..., Type T> requires ValidMemberIndex<T, I>
    [[nodiscard]] constexpr decltype(auto) GetMemberConst(T &&object)
    {
        return Traits<T>::template GetMember<I>(Meta::make_const(std::forward<T>(object)));
    }

    // Get `I`th member of a struct, mutable if the input is mutable.
    template <int I, Meta::Deduce..., Type T> requires ValidMemberIndex<T, I>
    [[nodiscard]] constexpr decltype(auto) GetMemberMutable(T &&object)
    {
        return Traits<T>::template GetMember<I>(std::forward<T>(object));
    }


    namespace detail
    {
        // If `Traits::GetMemberInfo()` returns a struct with a `::type` member that's not void, return that exactly.
        // Otherwise `decltype` the result of `GetMemberMutable()`, and remove cvref-qualifiers from that.
        template <TypeUnqualified T, int I>
        struct MemberType {using type = std::remove_cvref_t<decltype(GetMemberMutable<I>(std::declval<T &>()))>;};
        template <TypeUnqualified T, int I> requires(!std::is_void_v<typename decltype(Traits<T>::template GetMemberInfo<I>())::type>)
        struct MemberType<T, I> {using type = typename decltype(Traits<T>::template GetMemberInfo<I>())::type;};
    }

    // Returns the type of the `I`th struct member as declared. Cvref-qualifiers on `T` are ignored.
    template <Type T, int I> requires ValidMemberIndex<T, I>
    using MemberType = typename detail::MemberType<std::remove_cvref_t<T>, I>::type;
    // Returns the type of the `I`th struct member with the correct cvref-qualifiers, if any.
    // Respects cvref-qualifiers on `T` (but how exactly it does that depends on the type).
    template <Type T, int I> requires ValidMemberIndex<T, I>
    using MemberTypeCvref = decltype((GetMemberMutable<I>)(std::declval<T &&>()));


    namespace detail
    {
        // If `_adl_em_refl_StructGetMemberInfo()` returns a struct with an `::attrs` member, extract template arguments from that into a `Meta::TypeList<...>`.
        // Otherwise returns an empty `Meta::TypeList<>`.
        template <TypeUnqualified T, int I>
        struct MemberAttributes {using type = Meta::TypeList<>;};
        template <TypeUnqualified T, int I> requires requires{typename decltype(Traits<T>::template GetMemberInfo<I>())::attrs;}
        struct MemberAttributes<T, I> {using type = Meta::list_from<typename decltype(Traits<T>::template GetMemberInfo<I>())::attrs>;};
    }

    // Returns the `TypeList<...>` of attributes of the `I`th struct member. Cvref-qualifiers on `T` are ignored.
    // If no attributes are specified, this is empty.
    template <Type T, int I> requires ValidMemberIndex<T, I>
    using MemberAttributes = typename detail::MemberAttributes<std::remove_cvref_t<T>, I>::type;


    namespace detail
    {
        template <typename Base, typename ...A>
        struct FindAttributeLow {};

        template <typename Base, typename A0, typename ...A>
        struct FindAttributeLow<Base, A0, A...> : FindAttributeLow<Base, A...> {};

        template <typename Base, typename A0, typename ...A> requires std::is_base_of_v<Base, A0>
        struct FindAttributeLow<Base, A0, A...>
        {
            using type = A0;
            static_assert((!std::is_base_of_v<Base, A> && ...), "More than one matchiing attribute in the list.");
        };

        template <typename Base, typename List>
        struct FindAttribute {};

        template <typename Base, typename ...A>
        struct FindAttribute<Base, Meta::TypeList<A...>> : FindAttributeLow<Base, A...> {};
    }

    // Inspects the list of attributes of a member (`MemberAttributes<T, I>`) to find exactly `A` or a class inherited from it.
    // On success returns the found type. On failure triggers a SFINAE error. If more than one attribute matches, triggers a hard error.
    template <Type T, int I, AttributeOrBase A> requires ValidMemberIndex<T, I>
    using MemberFindAttribute = typename detail::FindAttribute<A, MemberAttributes<T, I>>::type;

    // Returns true if `I`th member variable of `T` has attribute `A` or an attribute inherited from it.
    // False if no such attribute. Hard error if more than one such attribute.
    template <Type T, int I, AttributeOrBase A> requires ValidMemberIndex<T, I>
    constexpr bool member_has_attribute = requires{typename MemberFindAttribute<T, I, A>;};


    // Does the struct provide member name information?
    // Even if there are no members, this can return different values.
    template <typename T>
    concept HasMemberNames = Type<T> && requires{Traits<T>::GetMemberName(0);};

    template <HasMemberNames T>
    [[nodiscard]] constexpr std::string_view GetMemberName(int i)
    {
        return Traits<T>::GetMemberName(i);
    }


    // This recognizes the tuple-like classes so we can provide an implementation for them.
    template <typename T>
    concept DefaultTupleLike = requires{std::tuple_size<std::remove_cvref_t<T>>::value;}; // `std::tuple_size_v` is not SFINAE-friendly.

    namespace detail
    {
        template <typename T, typename L>
        struct TupleMemberInfo {};

        template <typename T, std::size_t ...I>
        struct TupleMemberInfo<T, std::index_sequence<I...>> {using type = Meta::TypeList<MemberInfo<std::tuple_element_t<I, T>>...>;};
    }

    template <DefaultTupleLike T>
    struct DefaultTupleLikeTraits
    {
        static constexpr int num_members = int(std::tuple_size_v<T>);

        template <int I>
        [[nodiscard]] static constexpr decltype(auto) GetMember(auto &&self) \
        {
            using std::get;
            return get<I>(EM_FWD(self));
        }

        template <int I>
        [[nodiscard]] static constexpr auto GetMemberInfo()
        {
            using List = typename detail::TupleMemberInfo<T, std::make_index_sequence<std::tuple_size_v<T>>>::type;
            return Meta::list_type_at<List, I>{};
        }
    };
}

namespace em::Refl::custom
{
    template <Structs::DefaultTupleLike T>
    constexpr auto _adl_em_refl_StructFallback(int/*AdlDummy*/, const T *)
    {
        return Structs::DefaultTupleLikeTraits<T>{};
    }
}
