#pragma once

#include "em/macros/utils/forward.h"
#include "em/meta/common.h"
#include "em/meta/lists.h"
#include "em/refl/common.h"
#include "em/zstring_view.h"

#include <cassert>
#include <cstddef>
#include <tuple>
#include <type_traits>
#include <utility>

// This file lets you access both static and non-static members.

namespace em::Refl::Structs
{
    // Normally not useful, but if you used some of the lower-level maros from `em/refl/macros/structs.h` to inject custom member into the traits,
    //   then you'll find them here.
    // This causes a SFINAE error if the type doesn't have the traits.
    template <typename T>
    using Traits = decltype(_adl_em_refl_Struct(custom::AdlDummy{}, std::declval<const std::remove_cvref_t<T> *>()));

    namespace detail
    {
        // Here we try to get traits from `_adl_em_refl_Struct()` if that's available (that's generated by `EM_REFL(...)` or written manually by the user),
        //   and fall back to `_adl_em_refl_StructFallbackNonStatic()` otherwise (that's primarily for internal use, but you user can provide it too).
        // The fallback is used e.g. to provide traits for tuple-like types.
        // Note that the fallback function has a different return type, it returns the non-static traits directly, instead of a struct combining the two.

        template <typename T>
        struct SelectTraits
        {
            template <typename U = T>
            using type = decltype(_adl_em_refl_StructFallbackNonStatic(custom::AdlDummy{}, std::declval<const U *>()));
        };

        template <typename T>
        requires requires{typename Traits<T>::_em_NonStatic;}
        struct SelectTraits<T>
        {
            template <typename = T>
            using type = Traits<T>::_em_NonStatic;
        };

        // Access the internal traits struct for non-static members.
        template <typename T>
        using NonStaticTraits = typename detail::SelectTraits<std::remove_cvref_t<T>>::template type<std::remove_cvref_t<T>>;


        // Access the internal traits struct for static members.
        template <typename T>
        using StaticTraits = Traits<T>::_em_Static;

        // This isn't public because we don't want to expose the difference between having no static traits and 0 static variables.
        template <typename T>
        concept HasStaticTraits = requires{typename StaticTraits<std::remove_cvref_t<T>>;};

        template <typename T>
        struct NumStaticMember : std::integral_constant<int, 0> {};
        template <HasStaticTraits T>
        struct NumStaticMember<T> : std::integral_constant<int, StaticTraits<T>::num_members> {};
    }




    // A struct type. Must either contain `EM_REFL` macro or implement the same customization points.
    // This is used to check for the presence of zero or more non-static members.
    // Static members don't have a check, you're supposed to check every type for static members via `num_static_members > 0`.
    template <typename T>
    concept Type = requires{typename detail::NonStaticTraits<T>;};

    template <typename T>
    concept TypeUnqualified = Meta::cvref_unqualified<T> && Type<T>;


    // The number of non-static data members in a struct.
    template <Type T>
    constexpr int num_members = detail::NonStaticTraits<T>::num_members;

    template <typename T, int I>
    concept ValidMemberIndex = Type<T> && I >= 0 && I < num_members<T>;


    // The number of static data members in a struct.
    // Unlike `num_members`, this is valid for all types, and just returns 0 if there are no static members in it.
    template <typename T>
    constexpr int num_static_members = detail::NumStaticMember<T>::value;

    template <typename T, int I>
    concept ValidStaticMemberIndex = I >= 0 && I < num_static_members<T>;


    // The separation between const and non-const getters is to eventually help with undo-redo, if we ever implement that.

    // Get `I`th non-static member of a struct, as if the struct was const.
    template <int I, Meta::Deduce..., Type T> requires ValidMemberIndex<T, I>
    [[nodiscard]] constexpr decltype(auto) GetMemberConst(T &&object)
    {
        return detail::NonStaticTraits<T>::template GetMember<I>(Meta::make_const(std::forward<T>(object)));
    }

    // Get `I`th non-static member of a struct, mutable if the input is mutable.
    template <int I, Meta::Deduce..., Type T> requires ValidMemberIndex<T, I>
    [[nodiscard]] constexpr decltype(auto) GetMemberMutable(T &&object)
    {
        return detail::NonStaticTraits<T>::template GetMember<I>(std::forward<T>(object));
    }


    // Get `I`th static member of `T`, always const.
    // Cvref-qualifiers on `T` are ignored.
    template <typename T, int I, Meta::Deduce...> requires ValidStaticMemberIndex<T, I>
    [[nodiscard]] constexpr decltype(auto) GetStaticMemberConst()
    {
        if constexpr (detail::HasStaticTraits<T>)
            return detail::StaticTraits<T>::template GetMember<I, true>();
        else
            static_assert(Meta::always_false<Meta::ValueTag<I>, T>, "This type has no static member variables.");
    }

    // Get `I`th static member of `T`, possibly mutable (if the member isn't const).
    // Cvref-qualifiers on `T` are ignored.
    template <typename T, int I, Meta::Deduce...> requires ValidStaticMemberIndex<T, I>
    [[nodiscard]] constexpr decltype(auto) GetStaticMemberMutable()
    {
        if constexpr (detail::HasStaticTraits<T>)
            return detail::StaticTraits<T>::template GetMember<I, false>();
        else
            static_assert(Meta::always_false<Meta::ValueTag<I>, T>, "This type has no static member variables.");
    }


    namespace detail
    {
        // If `Traits::GetMemberInfo()` returns a struct with a `::type` member that's not void, return that exactly.
        // Otherwise `decltype` the result of `GetMemberMutable()`, and remove cvref-qualifiers from that.
        template <TypeUnqualified T, int I>
        struct MemberType {using type = std::remove_cvref_t<decltype(GetMemberMutable<I>(std::declval<T &>()))>;};
        template <TypeUnqualified T, int I> requires(!std::is_void_v<typename decltype(NonStaticTraits<T>::template GetMemberInfo<I>())::type>)
        struct MemberType<T, I> {using type = typename decltype(NonStaticTraits<T>::template GetMemberInfo<I>())::type;};

        // If `Traits::GetMemberInfo()` returns a struct with a `::type` member that's not void, return that exactly.
        // Otherwise `decltype` the result of `GetStaticMemberMutable()`, and remove cvref-qualifiers from that.
        template <typename T, int I>
        struct StaticMemberType {using type = std::remove_cvref_t<decltype(GetStaticMemberMutable<T, I>())>;};
        template <typename T, int I> requires(!std::is_void_v<typename decltype(StaticTraits<T>::template GetMemberInfo<I>())::type>)
        struct StaticMemberType<T, I> {using type = typename decltype(StaticTraits<T>::template GetMemberInfo<I>())::type;};
    }

    // Returns the type of the `I`th struct member as declared. Cvref-qualifiers on `T` are ignored.
    template <Type T, int I> requires ValidMemberIndex<T, I>
    using MemberType = typename detail::MemberType<std::remove_cvref_t<T>, I>::type;
    // Returns the type of the `I`th struct member with the correct cvref-qualifiers, if any.
    // Respects cvref-qualifiers on `T` (but how exactly it does that depends on the type).
    template <Type T, int I> requires ValidMemberIndex<T, I>
    using MemberTypeCvref = decltype((GetMemberMutable<I>)(std::declval<T &&>()));

    // Returns the type of the `I`th struct member as declared. Cvref-qualifiers on `T` are ignored.
    template <typename T, int I> requires ValidStaticMemberIndex<T, I>
    using StaticMemberType = typename detail::StaticMemberType<std::remove_cvref_t<T>, I>::type;
    // Returns the type of the `I`th struct member with the correct cvref-qualifiers, if any.
    // Ignores cvref-qualifiers on `T`.
    template <typename T, int I> requires ValidStaticMemberIndex<T, I>
    using StaticMemberTypeCvrefConst = decltype((GetStaticMemberConst<std::remove_cvref_t<T>, I>)());
    template <typename T, int I> requires ValidStaticMemberIndex<T, I>
    using StaticMemberTypeCvrefMutable = decltype((GetStaticMemberMutable<std::remove_cvref_t<T>, I>)());
    template <typename T, int I, bool IsConst>
    using StaticMemberTypeCvrefMaybeConst = std::conditional_t<IsConst, StaticMemberTypeCvrefConst<T, I>, StaticMemberTypeCvrefMutable<T, I>>;


    namespace detail
    {
        // If `Traits::GetMemberInfo()` returns a struct with an `::attrs` member, extract template arguments from that into a `Meta::TypeList<...>`.
        // Otherwise returns an empty `Meta::TypeList<>`.
        template <TypeUnqualified T, int I>
        struct MemberAttributes {using type = Meta::TypeList<>;};
        template <TypeUnqualified T, int I> requires requires{typename decltype(NonStaticTraits<T>::template GetMemberInfo<I>())::attrs;}
        struct MemberAttributes<T, I> {using type = Meta::list_from<typename decltype(NonStaticTraits<T>::template GetMemberInfo<I>())::attrs>;};

        // If `Traits::GetMemberInfo()` returns a struct with an `::attrs` member, extract template arguments from that into a `Meta::TypeList<...>`.
        // Otherwise returns an empty `Meta::TypeList<>`.
        template <typename T, int I>
        struct StaticMemberAttributes {using type = Meta::TypeList<>;};
        template <typename T, int I> requires requires{typename decltype(StaticTraits<T>::template GetMemberInfo<I>())::attrs;}
        struct StaticMemberAttributes<T, I> {using type = Meta::list_from<typename decltype(StaticTraits<T>::template GetMemberInfo<I>())::attrs>;};
    }

    // Returns the `TypeList<...>` of attributes of the `I`th non-static struct member. Cvref-qualifiers on `T` are ignored.
    // If no attributes are specified, this is empty.
    template <Type T, int I> requires ValidMemberIndex<T, I>
    using MemberAttributes = typename detail::MemberAttributes<std::remove_cvref_t<T>, I>::type;

    // Returns the `TypeList<...>` of attributes of the `I`th static struct member. Cvref-qualifiers on `T` are ignored.
    // If no attributes are specified, this is empty.
    template <typename T, int I> requires ValidStaticMemberIndex<T, I>
    using StaticMemberAttributes = typename detail::StaticMemberAttributes<std::remove_cvref_t<T>, I>::type;


    namespace detail
    {
        template <typename Base, typename ...A>
        struct FindAttributeLow {};

        template <typename Base, typename A0, typename ...A>
        struct FindAttributeLow<Base, A0, A...> : FindAttributeLow<Base, A...> {};

        template <typename Base, typename A0, typename ...A> requires std::is_base_of_v<Base, A0>
        struct FindAttributeLow<Base, A0, A...>
        {
            using type = A0;
            static_assert((!std::is_base_of_v<Base, A> && ...), "More than one matchiing attribute in the list.");
        };

        template <typename Base, typename List>
        struct FindAttribute {};

        template <typename Base, typename ...A>
        struct FindAttribute<Base, Meta::TypeList<A...>> : FindAttributeLow<Base, A...> {};
    }

    // Inspects the list of attributes of a non-static member (`MemberAttributes<T, I>`) to find exactly `A` or a class inherited from it.
    // On success returns the found type. On failure triggers a SFINAE error. If more than one attribute matches, triggers a hard error.
    template <Type T, int I, AttributeOrBase A> requires ValidMemberIndex<T, I>
    using MemberFindAttribute = typename detail::FindAttribute<A, MemberAttributes<T, I>>::type;

    // Inspects the list of attributes of a static member (`StaticMemberAttributes<T, I>`) to find exactly `A` or a class inherited from it.
    // On success returns the found type. On failure triggers a SFINAE error. If more than one attribute matches, triggers a hard error.
    template <typename T, int I, AttributeOrBase A> requires ValidStaticMemberIndex<T, I>
    using StaticMemberFindAttribute = typename detail::FindAttribute<A, StaticMemberAttributes<T, I>>::type;

    // Returns true if `I`th member variable of `T` has attribute `A` or an attribute inherited from it.
    // False if no such attribute. Hard error if more than one such attribute.
    template <Type T, int I, AttributeOrBase A> requires ValidMemberIndex<T, I>
    constexpr bool member_has_attribute = requires{typename MemberFindAttribute<T, I, A>;};

    // Returns true if `I`th member variable of `T` has attribute `A` or an attribute inherited from it.
    // False if no such attribute. Hard error if more than one such attribute.
    template <typename T, int I, AttributeOrBase A> requires ValidStaticMemberIndex<T, I>
    constexpr bool static_member_has_attribute = requires{typename StaticMemberFindAttribute<T, I, A>;};


    // Does the struct provide non-static member name information?
    // Even if there are no non-static members, this can return different values.
    // NOTE: Currently we don't provide the equivalent concept for static members, those are assumed to always have names.
    template <typename T>
    concept HasMemberNames = Type<T> && requires{detail::NonStaticTraits<T>::GetMemberName(0);};

    template <HasMemberNames T>
    [[nodiscard]] constexpr em::zstring_view GetMemberName(int i)
    {
        return detail::NonStaticTraits<T>::GetMemberName(i);
    }

    template <typename T>
    [[nodiscard]] constexpr em::zstring_view GetStaticMemberName(int i)
    {
        if constexpr (detail::HasStaticTraits<T>)
        {
            return detail::StaticTraits<T>::GetMemberName(i);
        }
        else
        {
            assert(false);
            return {};
        }
    }


    // This recognizes the tuple-like classes so we can provide an implementation for them.
    template <typename T>
    concept DefaultTupleLike = requires{std::tuple_size<std::remove_cvref_t<T>>::value;}; // `std::tuple_size_v` is not SFINAE-friendly.

    namespace detail
    {
        template <typename T, typename L>
        struct TupleMemberInfo {};

        template <typename T, std::size_t ...I>
        struct TupleMemberInfo<T, std::index_sequence<I...>> {using type = Meta::TypeList<MemberInfo<std::tuple_element_t<I, T>>...>;};
    }

    template <DefaultTupleLike T>
    struct DefaultTupleLikeTraits
    {
        static constexpr int num_members = int(std::tuple_size_v<T>);

        template <int I>
        [[nodiscard]] static constexpr decltype(auto) GetMember(auto &&self) \
        {
            using std::get;
            return get<I>(EM_FWD(self));
        }

        template <int I>
        [[nodiscard]] static constexpr auto GetMemberInfo()
        {
            using List = typename detail::TupleMemberInfo<T, std::make_index_sequence<std::tuple_size_v<T>>>::type;
            return Meta::list_type_at<List, I>{};
        }
    };
}

namespace em::Refl::custom
{
    template <Structs::DefaultTupleLike T>
    constexpr auto _adl_em_refl_StructFallbackNonStatic(int/*AdlDummy*/, const T *)
    {
        return Structs::DefaultTupleLikeTraits<T>{};
    }
}
